## 1. 定义层面对比

**进程**：具有一定独立功能的程序在某个数据集合上的一次运行活动，所包含的计算机执行环境的总和就是进程，进程是资源分配的基本单位，是系统进行资源分配和调度的一个独立单位

**线程**：线程是进程中能够并发执行的实体，是 CPU 调度和分配的基本单位；线程本身只拥有在运行时必不可少的资源（程序计数器 PC、寄存器和栈等），同属一个进程的线程共享进程拥有的全部资源，线程间主要通过共享内存通信

**协程**：是一种用户态的轻量级线程，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行，goroutine 就是一种协程

**goroutine**：是 Go 程序中的最基本的并发单元，创建一个 goroutine 的栈内存消耗为 `2KB`，根据实际的使用可以动态扩容；对比而言创建一个线程需要消耗至少 `1MB` 栈内存

> **补充**：我们编写的代码是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件时，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，这个运行的程序即是进程。
>
> 程序：源代码经过编译得到的二进制文件，其中包括了正常运行所需要的数据，这些数据加上代码本身存放在磁盘上，就是一个「程序」，或称为代码的可执行镜像（executable image）
>
> - 当程序被执行起来，就从磁盘上的二进制文件变成了内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合
> - 程序的静态表现是存放在磁盘上的文件；动态表现是程序运行起来后数据和状态的总和，即进程

<br>

## 2. 上下文开销层面对比

### 2.1 进程和线程

#### 发生上下文切换的情况

1. 时间片耗尽
2. 阻塞操作
3. 高优先级线程抢占



#### 线程开销

**硬件上下文切换**：切换 CPU 寄存器的内容，包括当前线程的寄存器状态，包括程序计数器（PC）、堆栈指针、通用寄存器等

**堆栈指针切换**：线程之间切换时需要切换堆栈指针，但通常是在同一个地址空间内切换用户栈和内核栈

**处理器调度**：操作系统的调度器会选择下一个线程执行，加载其上下文到 CPU

**系统调用**：如果涉及系统调用（如线程阻塞），需要在用户态和内核态之间切换



#### 进程开销

**硬件上下文切换**：切换 CPU 寄存器的内容，包括当前进程的寄存器状态，包括程序计数器（PC）、堆栈指针、通用寄存器等

**地址空间切换**：需要切换虚拟地址空间，涉及页表刷新、TLB 刷新

**处理器调度**：操作系统的调度器会选择下一个线程执行，加载其上下文到 CPU

**内核态和用户态切换**：进程切换通常涉及从一个进程的内核态切换到另一个进程的用户态或内核态

**系统资源切换**：需要更新进程控制块（PCB）中的资源信息，如文件描述符、信号处理、内存管理信息等





1. 切换到内核态（权限切换）
2. 切换硬件上下文（保存状态到 PCB、恢复 PCB 状态到 CPU）
3. 切换虚拟地址空间（涉及页表失效、TLB 刷新）

**线程**：开销相对进程有所减小，但不同进程的线程切换效率会退化为何进程切换类似

1. 切换到内核态（权限切换）
2. 切换硬件上下文

**协程**：开销很小，用户态直接执行，只需切换硬件上下文以及一些用户态的操作



### 2.3 goroutine

#### 发生上下文切换的情况

**goroutine 阻塞**：系统调用/Mutex/通道阻塞，被阻塞的 goroutine 会进入睡眠模式，让 Go 调度并运行一个等待的 goroutine。被阻塞的 goroutine 进入睡眠队列，就绪后再被 Go 调度

**时间片结束**：goroutine 在 P 的本地队列中执行时会被调度器分配一个时间片，当占用的时间片用完后，调度器会将其挂起，并切换到另一个 goroutine 执行

**主动让出 CPU**：goroutine 通过调用 `runtime.Gosched()` 主动让出 CPU



#### 开销

**硬件上下文切换**：调度器将当前 goroutine 寄存器状态、PC、堆栈指针从 CPU 保存到内存；再将新调度的 goroutine 的这些信息加载（恢复）到 CPU 的寄存器中

- 运行中 goroutine 的寄存器状态、PC、堆栈指针等信息存储在 CPU 中，这些是 CPU 执行 goroutine 指令需要的信息

**用户态操作**：从调度队列中选取下一个 goroutine（切换 g0），更新调度器中的相关数据结构

<br>

## 3. 内核态和用户态

### 3.1 什么是内核态和用户态

CPU 执行指令时有两种不同权限级别：

**内核态（Kernel Mode）**：运行操作系统程序、操作硬件，可以执行特权指令，访问系统资源等

**用户态（User Mode）**：运行用户程序，执行的是普通的用户程序指令

特权指令：只能由操作系统使用，用户程序不能使用的指令（启动I/O、修改程序状态字、设置时钟等）

非特权指令：用户程序可以使用的指令

- CPU特权分为四级：`R0-R3`，其中`R0`表示内核态，`R3`表示用户态



### 2.1 用户态和内核态的区别

处于用户态时，进程所能访问的内存空间和对象收到限制，CPU是可以被抢占的；处于内核态时，可以访问所有的内存空间和对象，CPU无法被抢占

- 当在系统中执行一个程序时，大部分时间是运行在用户态下的，运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，当需要操作系统帮助完成某些任务（如操作硬件）时，就会切换到内核态

![image-20240503130918125](../../../../../../../../static/image-20240503130918125.png)

- 内核态对应的内核空间只有一个，N个进程则有N个用户空间
- 对于每个进程来说，有独立的虚拟地址空间，其中包括独占的用户空间，和所有进程共享的内核空间

### 2.2 用户态和内核态的切换

`用户态->内核态`

**系统调用**：内核抽象出的给用户态调用的接口，申请使用操作系统提供的服务程序（如`fork()`）

**异常**：CPU 执行用户态程序时，发生无法预知的异常，内核态会接管（如缺页异常）

**中断**：外围设备完成用户请求操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行的指令转而去执行与中断信号对应的处理程序

`内核态->用户态`

CPU 进入用户态通常是由内核在必要时自动进行的







<br>

## 3. 对比总结













